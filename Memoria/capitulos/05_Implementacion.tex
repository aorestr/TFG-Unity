\chapter{Integración}\label{chap:Integration}
Trazado el esquema del trabajo a realizar, el siguiente paso es lógicamente llevarlo a cabo. Las soluciones empleadas para todo el proceso será lo que compongan este capítulo.

\section{Desarrollo de la API}
Si bien en la sección~\ref{sec:dis_api} ya se habló de la estructura con la que nuestra API contaría, en esta ocasión se contará con todo detalle el modo en el que esta ha sido desarrollada. Se describirán los puntos más importantes de cada una de las clases así como el modo en que fueron originados. Naturalmente, no se pretende explicar todo el contenido, pues no es su propósito. Se evitará así explicar en muchos casos métodos y propiedades privadas para centrarnos en aquellas públicas.

Para finalizar se explicará la relación existente entre las clases con ayuda de un diagrama UML así como la forma en la que estas han sido compiladas para ser unificadas como librería.

Todas estas clases conforman un único \texttt{namespace} o espacio de nombres. Conviene recalcar que la API ha sido enteramente desarrollada desde cero.

\subsection[GNS3sharp]{\href{https://github.com/aorestr/GNS3sharp/blob/master/gsn3sharp.cs}{GNS3sharp}}\label{subsec:gnscsclass}
\subsubsection{Constructor}
El constructor de \GNSCS~es sin duda uno de los elementos más importantes de toda a API. ¿Por qué? Tendrá la responsabilidad de conectarse al servidor de GNS3, recibir todos los datos de un cierto proyecto que solicitemos, procesarlos y guardarlos de tal forma que sean útiles. Su cabecera se muestra justo a continuación:
\begin{lstlisting}[language={[Sharp]C}, caption={Cabecera del constructor de \texttt{GNS3sharp}}, label={gnscs1}]
public GNS3sharp(string _projectID, string _host = "localhost", ushort _port = 3080)
\end{lstlisting}

Cosas que serán necesarias entonces para inicializarlo:
\begin{itemize}
\item \textbf{ID del proyecto}: cada proyecto de GNS3 tiene un ID asociado que el servidor guarda junto a su referencia. Más adelante, en la subsección \ref{subsec:aux}, veremos cómo no es necesario conocer el ID del proyecto sino que con el nombre del mismo será más que suficiente.
\item \textbf{Host}: la dirección del equipo donde el servidor está alojado. Por defecto se toma \texttt{localhost}; se supone que la mayor parte de las veces se encontrará en el mismo equipo desde el que se utiliza la API.
\item \textbf{Puerto}: además de la dirección del servidor, es necesario conocer el puerto en el que está montado. GNS3 determina el \texttt{3080} por defecto.
\end{itemize}

De acuerdo, ¿y qué hace exactamente con estos tres parámetros?
\begin{enumerate}
\item Crea la cadena de texto de la URI donde está el recurso asociado a los nodos del proyecto. En esta dirección existe únicamente un JSON con toda la información sobre él. Se instancia un cliente web y \textbf{se descarga el recurso como cadena de texto}.

\item Hay que \textbf{deserializar el JSON}. Este paso no es en absoluto trivial, ya que los métodos de \textit{Json.NET} son incapaces de extraer los datos que necesitamos directamente. Así que, valiéndonos de las herramientas en forma de clases que nos ofrece, lo hacemos manualmente.
\begin{lstlisting}[language={[Sharp]C}, caption={Deserialización de JSON}, label={gnscs2}]
// JSON array object
JArray jsonArray = JArray.Parse(json);
Dictionary<string,object> tempDict = new Dictionary<string, object>();

// Variables in which store the JSON info temporaly
string name; object value;        
if (jsonArray.HasValues){
    foreach (JObject jO in jsonArray.Children<JObject>()) {
        foreach (JProperty jP in jO.Properties()) {                
            name = jP.Name;
            value = (object)jP.Value;
            tempDict.Add(name,value);
            // The last key of every node
            if (jP.Name.Equals(lastKey)) {
                // If we do not copy the content of the dictionary into another
                // we will be copying by reference and erase the content once
                // we 'clear' the dict
                Dictionary<string, object> copyDict = new Dictionary<string, object>(tempDict);
                dictList.Add(copyDict);
                tempDict.Clear();
            }
        }
    }
}
\end{lstlisting}
Sin entrar mucho al detalle, lo que hace es parsear el objeto como objeto de tipo \texttt{JArray} y luego este se discretiza por cada elemento de esa cadena. Cada elemento representa a un nodo. Se recorre a su vez cada subelemento que lo conforma, que no son más que sus pares \textit{llave-valor}.

Los datos que se han extraído se guardan en una lista de diccionarios de par \texttt{<string,object>}. Se usa la clase genérica \texttt{object} porque el tipo del valor asociado a la clave varía.

\item Se hace lo mismo para los enlaces. El proceso es similar.

\item A partir de los objectos extraídos de la deserialización del JSON, se \textbf{crean las instancias representantes} de los nodos del proyecto. Existe un problema de cierta gravedad en esto: en el JSON no existe ningún parámetro que explicite de que tipo de nodo estamos hablando. Es decir, que no podemos conocer directamente con qué aparato concreto estamos tratando.

La solución que nosotros hemos tomado para sortear este problema es el añadir una etiqueta al nombre del nodo en el momento de la creación de la red en GNS3. Por ejemplo, si el nodo es un \textit{VPC} (nodo predefinido y propio del simulador), su nombre sería de la forma ``[VPC]NombreDelNodo''. Será necesario entonces definir una etiqueta por cada tipo de aparato a utilizar.

Sin embargo, sigue existiendo un problema de peso en todo esto: no conocemos el tipo de cada nodo antes del tiempo de ejecución (\textit{runtime}, en inglés) del código. En otras palabras, hasta el momento de la descarga y el análisis del JSON es imposible saber con qué tipo de nodos estamos lidiando, con lo que es a su vez imposible escribir el constructor que se va a utilizar. Recordemos que nuestra intención es usar una clase por cada modelo de nodo concreto. Por supuesto, se podría crear una sentencia condicional en la que, dependiendo de la etiqueta, llevara al constructor de una clase u otra. Sin embargo, requeriría de muchas líneas de código y sería necesario añadir más cada vez que se introduzca una nueva clase de modelo de aparato en la API.

La solución pasa entonces por lo que en programación se conoce como \textit{reflexión}. Poniéndolo en términos puramente técnicos: ``inspeccionar los metadatos y el código compilado en tiempo de ejecución se llama reflexión''\cite{csnutshell}.

\begin{lstlisting}[language={[Sharp]C}, caption={Instanciación de los nodos}, label={gnscs3}]
System.Reflection.ConstructorInfo ctor; int i = 0;
try{
    foreach(Dictionary<string, object> node in JSON){
        try{
            Console.WriteLine($"Gathering information for node #{i}... ");

            // Get the main constructor of the node type
            ctor = Aux.NodeType(node["name"].ToString()).GetConstructors(
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance
            ).Last();

            // Invoke the previous constructor and create the instance through it
            listOfNodes[i] = (Node)ctor.Invoke(
                new object[]{
                    node["console_host"].ToString(), 
                    ushort.Parse(node["console"].ToString()), 
                    node["name"].ToString(),
                    node["node_id"].ToString(),
                    GetNodeListOfPorts(node)
                }
            );
            
            nodesByName.Add(listOfNodes[i].Name, listOfNodes[i]);
            nodesByID.Add(listOfNodes[i].ID, listOfNodes[i]);
        } catch(Exception err1){
            Console.Error.WriteLine(
                "Impossible to save the configuration for the node #{0}: {1}", 
                i.ToString(), err1.Message
            );
        }
        i++;
    }
} catch(Exception err2){
    Console.Error.WriteLine(
        "Some problem occured while saving the nodes information: {0}",
        err2.Message
    );
    listOfNodes = null;
}
\end{lstlisting}
Con esto en mente pues, tomamos el tipo de la clase asociada al aparato mediante la etiqueta que ya hemos mencionado. Obtenemos gracias a él el constructor que nos es útil. El siguiente paso es invocarlo para generar la instancia del objeto. Previamente se pensó en utilizar el método \texttt{Activator.CreateInstance()}, que instancia un objeto directamente con los metadatos del tipo representante (representados a su vez por la clase \texttt{System.Type}) y los parámetros del constructor, pero solo funciona cuando los constructores son públicos y no es el caso de aquellos que usamos.

Añadimos la instancia a una lista donde se guardan todos los objetos representantes de los nodos. Esta propiedad se verá más adelante.

La obtención de las interfaces que cada nodo posee así como de cuáles están libres y cuáles están usadas por cierto enlace requiere de más trabajo que no se considera necesario explicar aquí.

\item Es ahora el momento de instanciar los enlaces a través de la información extraída previamente. Aunque el problema que vimos con los nodos no se va a dar aquí, la obtención de los enlaces y sus parámetros tampoco es fácil. La principal dificultad aparece, una vez más, cuando se trata con las interfaces de los nodos.

\begin{lstlisting}[language={[Sharp]C}, caption={Matcheo entre los enlaces y las interfaces de los nodos}, label={gnscs4}]
List<Dictionary<string,object>> dictList = null;
try{
    dictList = DeserializeJSONList(nodesJSON, "port_number");
} catch (Exception err){
    Console.Error.WriteLine(
        "Some problem occured while trying to gather information about the nodes connect to the link: {0}",
        err.Message
    );
}

if (dictList.Count > 0){
    // Iterates through the JSON dictionary
    foreach (Dictionary<string, object> nodeTemp in dictList){
        // Iterates through the nodes the link connects
        foreach (Node node in link.Nodes){
            if (node != null && node.ID.Equals(nodeTemp["node_id"].ToString())){
                // Search for the port that matches the found one
                var foundPort = node.Ports.Where(
                    x => (
                        x["adapterNumber"].ToString() == nodeTemp["adapter_number"].ToString() &&
                        x["portNumber"].ToString() == nodeTemp["port_number"].ToString()
                    )
                );
                // If exists, add the link into the key "link" of the ports list
                // of dictionaries of the node
                if (foundPort.Count() > 0) foundPort.First()["link"] = link;
            }
        }
    }
}
\end{lstlisting}

Una vez localizada la sección relacionada con los nodos en el diccionario que contiene la información de los enlaces extraída del JSON, se deserializa y se hace un barrido por entre esos nodos. Hecho esto, se busca entre los nodos que ya tenemos almacenados aquel que posea la misma ID que el del nodo sobre el que estamos barriendo. Si se encuentra, se busca la interfaz del mismo que dicte el nodo del barrido. De encontrarse, el puerto (usado aquí como sinónimo de interfaz) del nodo que teníamos almacenado guardará la información del enlace que contiene todos esos nodos que se están analizando. Es bastante confuso, sí.

El método principal que se encarga de la extracción de los enlaces, \texttt{GetLinks()}, se verá ayudado por un par de funciones declaradas localmente. Estas funciones locales aparecen por vez primera en C\#7.

Se guardan todos estos enlaces como lista en otra de las propiedades que se verán más adelante.

\item Finalmente, se añade a cada nodo la información de los enlaces a los que está conectado.

\end{enumerate}

\subsubsection{Propiedades}
\begin{itemize}
\item \texttt{ProjectID}, \texttt{Host} y \texttt{Port}: propiedades que se toman directamente de los parámetros que el constructor necesitaba.
\item \texttt{NodesJSON} y \texttt{LinksJSON}: diccionarios que contienen los JSON descargados desde el servidor una vez han sido parseados. Por lo general esta propiedad no tendría porque ser usada por un usuario que no esté desarrollando la API, pero se mantiene como \texttt{public} por si hay algún caso en el que sí.
\item \texttt{Nodes} y \texttt{Links}: posiblemente las propiedades más importantes de la clase. Son listas que contienen los objetos que representan los nodos y enlaces, respectivamente, del proyecto.
\end{itemize}

\subsubsection{Métodos}
La mayor parte de los métodos de esta clase son privados, pues son usados internamente como subrutinas de otros métodos más grandes. Sin embargo podemos encontrar algunos accesibles desde fuera de la clase:
\begin{itemize}
\item \texttt{StartNode()} y \texttt{StopNode()}: activan/desactivan un nodo del proyecto. Esto se consigue haciendo uso del método POST de REST hacia la URI correspondiente al nodo. En el código se lleva a cabo mediante la clase \texttt{System.Net.Http.HttpClient}, que provee las herramientas suficientes para enviar y recibir datos de un recurso web.

\begin{lstlisting}[language={[Sharp]C}, caption={Activación/desactivación de un nodo}, label={gnscs5}]
// First part of the URL
string URLHeader = $"http://{host}:{port}/v2/projects/{projectID}/nodes";

// Pack the content we will send
ByteArrayContent byteContent = null;
try{
    string content = JsonConvert.SerializeObject(new Dictionary<string, string> { { "", "" } });
    byteContent = new ByteArrayContent(System.Text.Encoding.UTF8.GetBytes(content));
    byteContent.Headers.ContentType = new MediaTypeHeaderValue("application/json");
} catch(JsonSerializationException err){
    Console.Error.WriteLine("Impossible to serialize the JSON to send it to the API: {0}", err.Message);
}

if (byteContent != null){
    try{
        responseStatus = HTTPclient.PostAsync(
            $"{URLHeader}/{node.ID}/{status}", byteContent
        ).Result.IsSuccessStatusCode;
    } catch(HttpRequestException err){
        Console.Error.WriteLine("Some problem occured with the HTTP connection: {0}", err.Message);
        responseStatus = false;
    } catch(Exception err){
        Console.Error.WriteLine("Impossible to {2} node {0}: {1}", node.Name, err.Message, status);
        responseStatus = false;
    }
} else{
    responseStatus = false;
}
\end{lstlisting}

\item \texttt{StartProject()} y \texttt{StopProject()}: activan/desactivan todos los nodos del proyecto. Se intentó paralelizar el activado/desactivado de los nodos sin resultado.
\item \texttt{SetLink()}: pasándole los objetos representantes de dos nodos del proyecto, es capaz de descubrir cuáles de sus interfaces están vacías y, de haber, crea un enlace entre ellas. También se consigue mediante POST. Actualiza \texttt{Links} y otra serie de parámetros tras la inserción. Es un método de cierta longitud (algo más de 100 líneas sin contar otras definidas fuera de las que hace uso). En este método y en similares es muy recurrido el tipo \texttt{dynamic}, que obliga al compilador a averiguar el tipo real de la variable en el momento de ejecución del código. Algo similar a lo que ocurre en lenguajes interpretados como Python y Matlab.
\item \texttt{EditLink()}: método polimórfico, pues dependiendo de si su parámetro es un \LINK~o dos \NODE~su comportamiento varía. Se parece a \texttt{SetLink()} pero este hace PUT y no POST a la URI. Ambas formas del método llaman a un método interno de \LINK. Tal y como su nombre indica, edita un enlace, permitiendo hacer variar los parámetros del mismo.
\item \texttt{RemoveLink()}: con la misma base polimórfica que el anterior. Elimina un enlace del proyecto de GNS3 con un DELETE e inmediatamente a su representante objeto.
\item \texttt{GetNodeByName()} y \texttt{GetNodeByID()}: dado un nombre o un identificador, respectivamente, devuelve el objecto representante de tal nodo.
\end{itemize}

\subsection[Node]{\href{https://github.com/aorestr/GNS3sharp/blob/master/node.cs}{Node}}
\subsubsection{Constructor}
El constructor principal de \NODE~solo es llamado desde \GNSCS. Es bastante sencillo: asigna parámetros básicos que la instancia de \GNSCS~toma del servidor. Entre ellos se encuentra la dirección del nodo. Gracias a ella y mediante otro método interno de la clase, se crea un cliente TCP y se establece un flujo de conexión para el envío y recepción de mensajes.

\begin{lstlisting}[language={[Sharp]C}, caption={Establecimiento de la conexión con el nodo}, label={node2}]
protected (TcpClient Connection, NetworkStream Stream) Connect(int timeout = 10000){
    // Network endpoint as an IP address and a port number
    IPEndPoint address = new IPEndPoint(IPAddress.Parse(this.consoleHost),this.port);
    // Set the socket for the connection
    TcpClient newConnection = new TcpClient();
    // Stream used to send and receive data
    NetworkStream newStream = null;
    try{
        newConnection.Connect(address);
        newStream = newConnection.GetStream();
        newStream.ReadTimeout = timeout; newStream.WriteTimeout = timeout;
    } catch(Exception err){
        Console.Error.WriteLine("Impossible to connect to the node {0}: {1}", this.name, err.Message);
        newConnection = null;
    }
    return (newConnection, newStream);
}
\end{lstlisting}

Especial atención a este método, que devuelve una tupla (recordemos, también nuevo en C\#7) en lugar de una simple variable.

Para que solo clases que pertenecen a esta librería puedan hacer uso del constructor, se ha aplicado el modificador de clase \texttt{internal}, el cual solo permite llamadas desde el espacio de nombres donde esté definido. Encapsulamiento en estado puro. La API no permite la creación de nodos nuevos así que se ha optado por ocultar este método del desarrollador final.

No obstante, sí que se incluye un constructor-clonador. Se trata de un constructor de clase cuyo parámetro de entrada es otro \NODE, de forma que se replica enteramente en una nueva instancia.

\begin{lstlisting}[language={[Sharp]C}, caption={Clonador de nodos}, label={node2}]
public Node(Node clone){
    this.consoleHost = clone.ConsoleHost; this.port = clone.Port;
    this.name = clone.Name; this.id = clone.ID; this.ports = clone.Ports;
    this.tcpConnection = clone.TCPConnection; this.netStream = clone.NetStream;
}
\end{lstlisting}

\subsubsection{Propiedades}
\begin{itemize}
\item \texttt{ConsoleHost} y \texttt{Port}: dirección y puerto donde el nodo está ubicado. Gracias a estos datos podremos establecer una conexión con el aparato.
\item \texttt{Name} y \texttt{ID}: nombre e identificador único del nodo. El nombre debería comenzar por \textit{[$<$EtiquetaDelNodo$>$]} para que \GNSCS~sea capaz de construir el objeto con la clase asociada a tal aparato.
\item \texttt{Ports}: interfaces que posee el nodo. Es un diccionario de tres llaves: ``adapterNumber'', ``portNumber'' y ``link''. Los dos primeros son parámetros que GNS3 asigna a las interfaces. El último guarda la referencia del enlace asociado a la interfaz en caso de que esté siendo utilizada y \texttt{null} si no.
\item \texttt{LinksAttached}: lista de \LINK. Referencias a los que el nodo está conectado.
\end{itemize}

\subsubsection{Métodos}
Esta clase destaca por sus dos métodos principales: \texttt{Send()} y \texttt{Receive()}.

\begin{itemize}
\item \texttt{Send()}: haciendo uso del flujo establecido durante la creación del objeto, se envía una cadena de texto previamente convertida a bytes. Antes de enviar cualquier mensaje, comprueba que es posible escribir en el canal.

\begin{lstlisting}[language={[Sharp]C}, caption={Envío de mensajes a un nodo}, label={node3}]
byte[] out_txt = Encoding.Default.GetBytes($"{message}\n");
this.netStream.Write(buffer: out_txt, offset: 0, size: out_txt.Length);
this.netStream.Flush();
\end{lstlisting}

\item \texttt{Receive()}: algo más complejo que \texttt{Send()}, hace también uso del canal establecido, aunque necesita de pasos adicionales para gestionar correctamente la información que se recibe.

Cada mensaje recibido se convierte en una cadena de texto que va siendo añadida a una lista. A cada nueva recepción se consulta al canal si existe nueva información a leer; si no, se esperan unos segundos confiando en que existan datos a procesar por parte del servidor. Se vuelve a hacer la comprobación y, si efectivamente no queda nada más por leer, se analizan las líneas recibidas en busca de caracteres inválidos y se guardan. 

\end{itemize}

\subsubsection{Destructor}
Esta es la única clase de la librería que hace uso de un destructor personalizado. Los destructores ayudan a definir las sentencias que serán ejecutadas junto antes de que el objeto en cuestión sea destruido (se desreferencie).

Únicamente se encarga de cerrar la conexión establecida con el nodo.

\subsection{Herederos de Node}
La clase \NODE~no hace más que de padre para todo un abanico de clases. A partir de ahí se crea una estructura en árbol desde la que se ramifica una serie de subclases. Las tres herederas directas son \texttt{Router}, \texttt{Switch} y \texttt{Guest}, correspondientes a los tres amplios grupos de nodos que pueden encontrarse en GNS3. Estas tres clases son abstractas; su labor no es otra que la de declarar métodos importantes que cada uno de estos aparatos se espera que posean.

La definición de los métodos se encuentra en sus clases herederas, que no representan otra cosa que dispositivos concretos. Pongamos un ejemplo para que se vea más sencillo:

\NODE~es la clase padre. Define el constructor, la forma de establecer la conexión con los nodos y los métodos para enviar y recibir mensajes de estos. De esta clase parte otra, \texttt{Router}, que por consiguiente es hija suya. Esta clase declara métodos abstractos que se espera que las clases representantes de los routers posean, como por ejemplo \texttt{GetIPByInterface()}, que dado el nombre de una interfaz ha de ser capaz de averiguar cuál es su IPv4 asociada. Finalmente, la clase \texttt{OpenWRT} va a heredar de \texttt{Router}. Definirá los métodos abstractos de la anterior y los suyos propios.

Es muy importante señalar que cada una de estas clases representantes de aparatos concretos deberán contar con una propiedad estática que contiene la etiqueta que el nodo deberá tener en su nombre. De nuevo con ejemplo: si queremos que el constructor de \GNSCS~pueda construir correctamente el objeto representante a un router OpenWRT de nuestro proyecto de GNS3, es necesario que a este se le ponga por nombre algo como \textit{[OPENWRT]NombreDelRouter}. De esta forma, automáticamente y una vez más haciendo uso de reflexión, la API es capaz de encontrar la clase a la que se hace referencia.

\begin{lstlisting}[language={[Sharp]C}, caption={Etiqueta de \texttt{OpenWRT}}, label={herederosnode1}]
private const string label = "OPENWRT";
/// <summary>
/// Label you must set in the name of the node at the GNS3 project
/// <para>Name of the node must look like "[OPENWRT]Name"</para>
/// </summary>
/// <value>Label as a string</value>
public static string Label { get => label; }
\end{lstlisting}

Si se hace correctamente, se instanciará un objeto \texttt{OpenWRT}. De lo contrario, se optará por el genérico \NODE.

Este punto del trabajo es importante. Una de las cosas que más nos interesaban de la creación de la API era su reutilización por manos ajenas. La estructura establecida en ella permite que cualquiera que quiera hacer uso de ella y pretenda implementar un cierto tipo de nodos en su proyecto de GNS3 lo tenga fácil a la hora de crear un tipo que le dé soporte en la librería.

Actualmente GNS3 cuenta con implementaciones de docenas de dispositivos de gestión de red del mercado. Crear una clase representante de todas ellas es ciertamente un trabajo inviable. Sin embargo, se ha buscado que cada usuario que haga uso de ella lo tenga fácil para insertar la que necesite. Tan solo necesita añadir una clase que herede de su tipo de aparato correspondiente (\texttt{Router}...) y definir los métodos que le gustaría que esta tuviera.

El número de métodos definidos para cada clase va en función de las necesidades de cada uno. Un dispositivo real cuenta con cientos de funciones; abstraerlas todas como métodos es descabellado.

A continuación se muestra uno de los métodos que nosotros hemos generado para \texttt{OpenWRT}, clase que ha sido usada abundantemente en la integración final de este proyecto ya que el router al que hace referencia nos ha sido de gran utilidad.

\begin{lstlisting}[language={[Sharp]C}, caption={Método \texttt{GetIPByInterface()} de \texttt{OpenWRT}}, label={herederosnode2}]
public override string[] GetIPByInterface(string iface){

    string GetParameterIfconfig(string _iface, string type){

        string result = null; string command = null;
        if (type.Equals("IP"))
            command = $"ifconfig {_iface} | grep 'inet addr' | cut -d: -f2 | awk '{{print $1}}'";
        else if (type.Equals("NETMASK"))
            command = $"ifconfig {_iface} | grep 'inet addr' | cut -d: -f4 | awk '{{print $1}}'";
        if (command != null){
            string lineTemp;
            Send(command);
            foreach (string line in Receive()) {
                lineTemp = line.Trim();
                if (Aux.IsIP(lineTemp)){
                    result = lineTemp;
                    break;
                }
            }
        }
        return result;

    }

    return new string[]{ 
        GetParameterIfconfig(iface, "IP"), GetParameterIfconfig(iface, "NETMASK") 
    };
    
}
\end{lstlisting}

El método se encarga de encontrar la IP relacionada con cierta interfaz del router. Básicamente, envía un comando al router mediante \texttt{Send()} y de la respuesta obtenida con \texttt{Receive()} extrae la IP.

La conclusión que ha de sacarse de esto es que todos los métodos, o la mayor parte de ellos, van a ser definidos en base a estas dos funciones, \texttt{Send()} y \texttt{Receive()}. Podemos llevar esta lógica algo más allá: si no existe método creado en cierta clase para realizar una operación que nos es necesaria, podemos hacer uso de aquellas dos funciones para, sobre la marcha, conseguir lo que esperamos.

\subsection[Link]{\href{https://github.com/aorestr/GNS3sharp/blob/master/link.cs}{Link}}
\subsubsection{Constructor}
Una vez más, el constructor es únicamente accesible desde el espacio de nombres y solo será llamado desde \GNSCS. Se han definido dos concretamente: uno que supone que todos los parámetros del enlace de GNS3 son nulos (es un enlace ideal) y otro que supone que al menos uno de ellos es distinto.

\subsubsection{Propiedades}
\begin{itemize}
\item \texttt{ID}: identificador único del nodo. Como el resto de IDs, lo asigna automáticamente GNS3.
\item \texttt{Nodes}: array de objetos \NODE~que contienen los objetos representantes de los nodos que el enlace une en el proyecto.
\item Parámetros del enlace: \texttt{FrequencyDrop}, \texttt{PacketLoss}, \texttt{Latency}, \texttt{Jitter} y \texttt{Corrupt}. Son parámetros que GNS3 permite para eliminar idealidades de las conexiones. Todos son números enteros.
\end{itemize}

\subsubsection{Métodos}
Esta clase solo cuenta con un método, \texttt{EditLink()}. Permite editar uno de los parámetros del enlace. Para ello, además de ser este alterado en el objeto, se modifica en el proyecto de GNS3 haciendo un PUT a la URI asociada al enlace. Ya se mencionó este método tratando uno de los de \GNSCS.

\subsection{Clases auxiliares}\label{subsec:aux}
\begin{itemize}
\item \texttt{Aux}: define métodos de ayuda para otras clases del espacio de nombres como un identificador de direcciones IP. También se encarga de generar, mediante reflexión, un mapeo entre los tipos de nodos existentes en la API y la etiqueta asociada a ellos. Todo esto es realizado de forma automática.
\item \texttt{RoutingTable}: define una estructura para las tablas de enrutamiento. Es usada por las clases herederas de \texttt{Router} para una gestión más eficiente de esas tablas. Dentro de la propia clase se define un \texttt{struct} usado para trabajar más cómodamente con cada una de las rutas de la tabla. 
\item \texttt{ServerProjects}: en esta clase deben definirse métodos asociados a la URI del server donde se lista el conjunto de proyectos definidos en él. Por el momento solo cuenta con un método (\texttt{GetProjectIDByName()}) que extrae el ID de un proyecto dado su nombre, realmente útil a la hora de instanciar \GNSCS.
\end{itemize}

\subsection{Estructura de la API}
A continuación se muestra el diagrama UML de la API, desde el que puede observarse esquemáticamente el diseño de cada una de las clases y la relación que existe entre ellas.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{imagenes/diagrama_api2}
  \caption{Diagrama UML de la API}
  \label{fig:uml_api}
\end{figure}

\subsection{Compilación}
C\# es un ``lenguaje gestionado'' (del inglés \textit{managed code}) pues es compilado en código gestionado. Este código gestionado es representado en un lenguaje intermedio. Aparece entonces la figura del \textit{Common Language Runtime} (CLR), núcleo del Microsoft .NET Framework. Se encarga de traducir este código intermedio al código nativo de la máquina desde la que se ejecuta.

Los contenedores de código gestionado se llaman ensamblados, y pueden ser archivos ejecutables (\textit{.exe}) o bien librerías (\textit{.dll})\cite{csnutshell}. Nuestro propósito es el de contener el código de la API en un ensamblado para librerías.

El editor de código Visual Studio de Microsoft tiene integradas decenas de herramientas para trabajar con proyectos dirigidos a .NET. Así, entre otras muchas cosas, facilita la compilación del código en C\# para extraer de él un ensamblado que pueda ser incluido en otro proyecto como librería externa.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.225]{imagenes/creacion_ensamblado}
  \caption{Elección del tipo de proyecto en Visual Studio 2017}
  \label{fig:creacion_ensamblado}
\end{figure}

Como framework con el que realizar la compilación se ha elegido \textit{.NET Standard 2.0}. De esta forma la librería será portable y correrá sin modificaciones en versiones modernas de todos los frameworks principales de .NET (.NET Core, .NET Framework...) pues únicamente posee el núcleo común de todos ellos. En realidad, .NET Standard no es un Framework: es simplemente una especificación que describe una base mínima de funcionalidad (tipos y miembros), que garantiza la compatibilidad con un cierto conjunto de frameworks.

Para el correcto ensamblado del código de la API hará falta la importación de dos librerías externas: \href{https://www.nuget.org/packages/Newtonsoft.Json/}{\textit{Json.NET}}, como ya se ha dicho en varias ocasiones, y \href{https://www.nuget.org/packages/Microsoft.CSharp/}{\textit{Microsoft.CSharp}}. Esta última, no incluida por defecto en .NET Standard, añade funcionalidades para la compilación dinámica de código (el modificador de acceso \texttt{dynamic} o el propio instanciador de clases por reflexión).

Con el fin de facilitar a los desarrolladores la importación de código de terceros, Visual Studio integra una herramienta que permite instalar esas dependencias en tus proyectos a través de \textit{NuGet}. NuGet es el formato de empaquetamiento de librerías de .NET para simplificar su compartición. Cuenta con una plataforma de hosting donde hospedar paquetes públicos paraser descrgados con facilidad por el resto de desarrolladores. La herramienta de Visual Studio se conecta directamente a este host, descarga el paquete y lo instala en el proyecto que esté siendo usado. Las dos librerías señaladas anteriormente se encuentran en tal plataforma.

Establecidos una serie de parámetros que servirán de metadatos para el ensamblado, se compila el proyecto. Visual Studio crea entonces el archivo \textit{.dll} así como un archivo \textit{.xml} que, enlazado al ensamblado, aporta la documentación de nuestra librería. Para lograr esto último fue necesario la inclusión de etiquetas XML como encabezado de cada uno elemento de la API (clases, métodos, propiedades...) cuya sintaxis puede \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/xml-documentation-comments}{consultarse online}. Similar al Javadoc de Java.

Ya tenemos preparada la librería para que Unity haga uso de ella.

\subsection{GitHub y la comunidad}
Hemos considerado esencial que la API sea reutilizable. El objetivo de su desarrollo en ningún caso ha sido el de nacer y morir para el presente trabajo. Lejos de esto, se pretende que esta librería pueda ser utilizada por quien quiera, ya tenga como propósito la construcción de un videojuego o cualquier otra aplicación.

Con esto en mente, todo el código utilizado por la librería se encuentra disponible en \MYhref{https://github.com/aorestr/GNS3sharp}{este repositorio} de mi GitHub personal. Está liberado bajo una licencia MIT, tremendamente permisiva a la hora de reutilizar el código.

Además de los archivos de la propia API, se puede encontrar un README que explica algunos puntos importantes que considerar a la hora de utilizarla. En el repositorio de GitHub existe asimismo una sección de ``releases'', donde se suben los distintos compilados de la librería en formato ``.dll'' a medida que esta se expande o se reparan problemas aparecidos. Por supuesto, todo el código y su documentación están escritos en inglés para así llegar a más desarrolladores.


\section{Desarrollo del videojuego}
En esta sección se detalla la construcción del videojuego. En primer lugar se habla del juego en sí, qué se ha creado y qué no y qué se puede esperar de él. Inmediatamente después se describe el entorno generado en GNS3 para ser usado por Unity para, más adelante, mostrar cómo y qué ha sido desarrollado mediante él.

\subsection{Descripción del juego}
Aunque al comienzo el propósito del proyecto era desarrollar algo similar a lo descrito en la subsección \ref{subsec:modelojuego}, la complejidad existente para llevarlo a cabo era demasiado grande. En su lugar, se ha preferido crear un único pequeño escenario que sirva como demostración del potencial del proyecto.

Con este propósito, se desarrollará un minijuego basado en tablas de enrutamiento. El objetivo del jugador es ser capaz de alcanzar un dispositivo marcado de la red en el menor tiempo posible. Por supuesto, habrá de atravesar una serie de nodos para alcanzarlo.

El mapa estará compuesto por varias plataformas y en cada una de ellas un cartel con la tabla de enrutamiento del respectivo router. Son estas plataformas entonces una suerte de representantes de los routers de la red. Al jugador se le darán varias posibles opciones como siguiente salto. Cada opción es una interfaz del router.

Con este nivel tan sencillo conseguimos dos cosas:
\begin{itemize}
\item Dar un ejemplo de juego didáctico con redes. Se ponen a prueba los conocimientos del jugador sobre redes y se le anima a hacerlo lo mejor posible a través de un contador ascendente.
\item Mostrar cómo se lleva a cabo la interacción entre el simulador y el juego. Dicho en otras palabras, demostrar que, efectivamente, la API es funcional y puede ser usada con el propósito que se esperaba.
\end{itemize}

Se cimentan unos pilares sobre los que podrán construirse cosas mucho mayores en el futuro.

\subsection{El proyecto de GNS3}
Para empezar será necesario construir la red sobre la que se apoyará el videojuego. Se ha construido una pequeña, de apenas cinco routers y dos PCs, uno como plataforma de inicio y otro como destino a alcanzar.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.225]{imagenes/redGNS3}
  \caption{Red desplegada para el videojuego}
  \label{fig:esquematico_red}
\end{figure}

La figura \ref{fig:esquematico_red} está tomada directamente de la red desplegada en GNS3. Se comentarán a continuación los distintos aparatos usados y el modo en que han sido configurados.

\subsubsection{Dispositivos usados}
\begin{itemize}
\item \textbf{VPCs}: Los VPCs son unos de los pocos nodos interactivos que GNS3 incluye por defecto. Como su propio nombre indica, no son más que PCs virtuales que incluyen \textbf{funciones básicas} que se espera que un PC pueda usar en una red. Entre esas funciones está la de asignar una dirección a su interfaz y la de lanzar PINGs a través de ella. VPC es una gran herramienta para añadir hosts simples a GNS3 y probar la conectividad entre los nodos\cite{bookGNS}.

Nuestra red cuenta con dos de ellos: \textit{[VPC]L1PC1} y \textit{[VPC]L1PC2}. Nótese la etiqueta con la que comienza su nombre, ya que como se comentó en anteriores ocasiones, esta sirve para que la API sea capaz de instanciar el objeto cuya clase representa este tipo de nodos (en este caso, la clase \texttt{VPC}). Solo consumen 2MB de RAM y la propia máquina anfitriona puede encargarse de gestionarlos (no es necesario pasar por GNS3 VM \textbf{ESTE CONCEPTO SERÁ EXPLICADO CUANDO HABLEMOS DE GNS3 AL COMIENZO}).

El único papel con el que cuentan estos dispositivos es el de representar mediante una dirección el inicio y el final del escenario.

\item \textbf{OpenWRT}: OpenWrt es una distribución GNU/Linux altamente extensible para dispositivos embebidos (típicamente routers inalámbricos). A diferencia de muchas otras distribuciones para estos routers, OpenWrt está construido desde cero para ser un sistema operativo completo y fácilmente modificable para el router. Esto significa que es posible tener todas las características que son necesarias en estos dispositivos con el añadido que corresponde a contar con un núcleo Linux\cite{aboutopenwrt}.

La principal razón por la que se eligió esta arquitectura como dispositivo de enrutamiento para el proyecto es su \textbf{gratuidad}: el proyecto OpenWRT es open source liberado bajo una licencia GPL. Debido a esto y a su filosofía de ``cada uno adapta su sistema operativo a sus propias necesidades particulares'', no se trata del firmware idóneo para un router al uso. Sin embargo, para nuestro propósito es más que suficiente.

Al estar basado en un sistema operativo Linux, gran parte de los comandos más famosos relacionados con redes como \texttt{ifconfig} aparecen aquí. Es un punto a su favor si conocemos tal arquitectura y las posibilidades que ofrece.

GNS3 cuenta con ``plantillas'' con las que se facilitar el importado de dispositivos como nodos a GNS3. Con el fin de incluir aparatos con OpenWRT instalado usamos la plantilla que puede descargarse desde \MYhref{https://www.gns3.com/marketplace/appliance/openwrt-2}{aquí}. Una vez descargada, siguiendo una serie de pasos GNS3 permite importar el nodo con mucha facilidad. La versión del firmware de OpenWRT que nosotros usamos es la 15.05.1. Slgo antigua considerando que data de 2016 y la última versión estable es la 18.06.1.

Todos los nodos que usen OpenWRT han de ser instalados en GNS3 VM, pues el simulador no permite de ningún modo que la máquina anfitriona sea la encargada de gestionarlos. La mayor parte de los aparatos cuyas imágenes son de cierta complejidad como este están obligados a ser usados de este modo.

Cinco de estos dispositivos han sido desplegados en la red. El camino más rápido para cruzar del primer PC1 al PC2 sería, en condiciones normales, \textit{[OPENWRT]L1R1} $\rightarrow$ \textit{[OPENWRT]L1R3} $\rightarrow$ \textit{[OPENWRT]L1R5}.

Las redes que han sido marcadas en los enlaces de la figura \ref{fig:esquematico_red} son únicamente orientativas ya que, como se explicará en el apartado siguiente, se ha pseudo-aleatorizado el establecimiento de estas. De nuevo, atención a \textit{[OPENWRT]} en el nombre de los routers: es la etiqueta asociada a la clase \texttt{OpenWRT} para que \GNSCS~pueda instanciar el objeto apropiado.

\item Otros dispositivos que consideramos añadir pero que, finalmente, por la simplicidad del diseño no se incluyeron, son el switch multicapa \MYhref{https://www.openvswitch.org/}{\textbf{Open vSwitch}} y la variante de Tiny Core, distro Linux altamente modular, \MYhref{https://docs.gns3.com/appliances/microcore-linux.html}{\textbf{Micro Core}}. Ambos son dispositivos de uso libre y gratuito, de ahí nuestro interés por ellos.
\end{itemize}

\subsubsection{Despliegue}
Los dispositivos se han interconectado tal y como se aprecia en la ilustración \ref{fig:esquematico_red}. Ninguno de los enlaces cuenta con tipo alguno de filtro, con lo que se consideran ideales.

Por sencillez, todas las redes establecidas en el despliegue tiene máscara de red de 24 bits. Todas ellas son de la forma \texttt{192.168.x0.y}, donde \texttt{x} es un número que se aleatoriza con cada arranque del juego mediante programación (hablaremos de esto cuando se detalle el apartado técnico de construcción del mismo) e \texttt{y} el número asociado a la interfaz del dispositivo que está conectada a esa red. Así, como ejemplo y suponiendo que las redes de la figura citada son las definitivas, a la interfaz de arriba de L1R1 (\texttt{eth3}) se le asignaría la dirección \texttt{192.168.20.3}. En el caso de los PCs, \texttt{y} sera en ambos casos \texttt{11}.

Al arrancar la red (al inicializar cada nodo), los VPCs son funcionales casi inmediatamente. No obstante, no es el caso en absoluto de los routers. Al tratarse de dispositivos que emulan aparatos reales, con un sistema operativo de cierta envergadura, es necesario \textbf{esperar para que su arranque sea completo}. Así, los nodos con OpenWRT necesitan una media de \textbf{HAZ AQUÍ PRUEBAS REALES} minutos en el PC desde el que se han realizado las pruebas para ser completamente funcionales. Esto implica que, o bien se ha de tomar la precaución de que todos los dispositivos estén iniciados al comenzar el juego, o bien que el jugador ha de esperar el tiempo necesario para que los aparatos comiencen a estar disponibles.

La problemática pasa a ser doble, ya que \textbf{GNS3 no guarda el estado de las máquinas tras su apagado}. Por más información que se ha buscado para intentar paliar este inconveniente, nada parece ser efectivo. La consecuencia natural es, por consiguiente, que el dispositivo habrá de ser configurado cada vez que se reinicie. Este no es un problema per se, pues gracias a la API puede llevarse a cabo mediante unas líneas de código con total facilidad; el verdadero problema es que, aún así, configurar todas las interfaces de un proyecto lleva tiempo. Se ha calculado cuánto tarda el de la nuestra y es \textbf{AÑADIR AQUÍ DATOS}. El tiempo podría ser minimizado si cada router es configurado paralelamente.

Todo lo anterior se resume en:
\begin{enumerate}
\item La asignación de direcciones se aleatoriza gracias a las posibilidades de scripting de la API.
\item Los routers requieren de un cierto tiempo de arranque, en absoluto inmediato, para ser completamente funcionales.
\item La configuración de los dispositivos es descartada cada vez que son apagados, con lo que es necesario reconfigurarlos tras cada arranque. Esto lleva implícito una inevitable inversión de tiempo.
\end{enumerate}

\subsection{El proyecto de Unity}
En esta sección se describe tanto el diseño del nivel de nuestro juego como el proceso que se ha seguido para materializarlo. Se comenzará señalando los materiales que han posibilitado la construcción del escenario.

\subsubsection{Materiales}
\begin{itemize}
\item El fondo es una imagen estática tomada de \MYhref{https://opengameart.org/content/industrial-background-2d}{OpenGameArt}, una famosa web que publica arte redistribuible para la elaboración de juegos. Está liberado bajo una licencia	\href{CC 3.0}{https://creativecommons.org/licenses/by/3.0/}, lo que implica que puede ser compartido y copiado siempre y cuando se dé crédito al autor y una referencia al material. Un enlace desde donde puede ser encontrado ya se ha dejado en la línea anterior. Gracias a ``Alucard'' por esta imagen.
\item El decorado del nivel se ha generado gracias a un conjunto de sprites localizados una vez más en \MYhref{https://opengameart.org/content/sci-fi-platform-tiles}{OpenGameArt}. En esta ocasión, el material tiene licencia \href{https://creativecommons.org/publicdomain/zero/1.0/}{CC0 1.0}, de dominio público; totalmente libre.

Un sprite es más un mapa de bits usado como elemento individual cuyo conjunto posibilita crear escenas en un videojuego. Si atendemos a esa definición y reparamos en la imagen a la que puede accederse desde el enlace anterior, es evidente que esa descripción no se corresponde a la figura. Digamos que esa imagen está formada por decenas de pequeños sprites y es tarea nuestra el extraerlos para nuestro propio uso. Unity nos lo pone fácil, ya que contiene una herramienta llamada ``sprite editor'' (visible en la figura \ref{fig:sprite_editor}), que disecciona imágenes para convertirlas en pequeñas piezas. Si los sprites están repartidos con un tamaño fijo en la imagen, como es nuestro caso, es tan sencillo como indicarle tal dimensiones en píxeles y Unity hará el resto.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.175]{imagenes/sprite_editor}
  \caption{Editor de sprites de Unity}
  \label{fig:sprite_editor}
\end{figure}

Ya veremos de qué modo son usados los sprites en el siguiente apartado.

\item Finalmente, nos hemos visto ayudados por uno de los paquetes que Unity incluye por defecto. Se trata del paquete ``2D'', que puede ser descargado desde el propio cliente de Unity en \textit{Assets} $\rightarrow$ \textit{Import package} $\rightarrow$ \textit{2D}. Incluye una serie de assets (\textbf{ESTE CONCEPTO DEBE EXPLICARSE LA PRIMERA VEZ QUE SE HABLE DE UNITY}) básicos para la creación de niveles bidimensionales. 

\end{itemize}

\subsubsection{Creación del juego}
El juego cuenta con, únicamente, dos escenas. La primera, aquella que aparece justo al ser inicializado, consta de únicamente una interfaz de usuario (GUI) que pide al jugador que pulse ``espacio'' para comenzar a jugar. Al hacerlo, se crea una instancia de \GNSCS~y se configura toda la red de GNS3 que pudimos ver en la figura \ref{fig:esquematico_red}. Todo el aspecto relacionado con la programación podrá estudiarse en el punto siguiente.

Pasado un tiempo, después de que todo quede configurado, Unity toma los datos necesarios del proyecto de GNS3 para construir la siguiente escena, la principal.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.175]{imagenes/monieco}
  \caption{Plataforma del nivel del juego}
  \label{fig:monieco}
\end{figure}

En la figura \ref{fig:monieco} pueden apreciarse los elementos más importantes del escenario:

\begin{itemize}
\item Por un lado \textbf{el protagonista}, el objeto sobre el que el jugador tiene poder. Se controla como en cualquier juego de plataformas bidimensional (crucetas para moverse, espacio para saltar...). El personaje es uno de los assets que el paquete ``2D'' trae consigo, con lo que no fue necesario ningún tipo de programación adicional. Cuenta con físicas ya definidas a través de un elemento \texttt{Rigidbody 2D} (deja a un objeto bajo el control del motor de físicas de Unity\cite{rigidbody}) y un par de elementos collider (definen la forma de un objeto para las colisiones físicas\cite{colliders}).
\item Las \textbf{paredes} del escenario están construidas con sprites procesados como ``tiles''. Los tiles son objetos que permiten a un sprite ser renderizado en un ``tilemap''\cite{tiles}. Los tilemaps son, a su vez, una redecilla de cuadrículas donde se permite la inserción de estos tiles. Todo esto no es más que una herramienta que facilita la creación de niveles. 
\item El \textbf{suelo} del escenario también está formado por tiles. Sin embargo, la diferencia con los anteriores reside en que el tilemap sobre el que están montados contiene un elemento adicional: consta de un \texttt{Tilemap Collider 2D}. Este elemento otorga automáticamente físicas de colisión a todos los tiles que incluyamos en el tilemap. Ello significa que todo tile introducido en el tilemap desplegado colisionará con el protagonista, permitiendo a este moverse sobre él.
\item Las \textbf{puertas} son la representación de las interfaces de los routers en el videojuego. Llevan a un nodo o a otro. Son, de nuevo, tiles, sobre los que se han dispuesto objetos vacíos que únicamente tienen un \texttt{Box Collider 2D} como elemento integrado. Posee un ``trigger'' (disparados) que manda una señal cada vez que un objeto colisiona con él.
\item Los carteles de las \textbf{tablas de encaminamiento}. Necesitan ser llenados con la información que se extraiga directamente de los routers.
\end{itemize}

Para terminar este apartado, se facilita una vista más general del escenario en la figura \ref{fig:nivel}, donde pueden observarse las distintas plataformas que lo conforman.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.175]{imagenes/nivel}
  \caption{Escenario creado}
  \label{fig:nivel}
\end{figure}

\subsubsection{Scripting}
El \textit{scripting} de un videojuego no es más que la programación que existe en él para llevar a cabo toda la lógica que lo rige.
